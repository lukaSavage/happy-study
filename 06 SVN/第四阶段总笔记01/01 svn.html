<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
<script>
/* 
★★★★★★★★★★★ 1.SVN ★★★★★★★★★★★★★★★
一、svn概述
    1.为什么要使用版本控制器svn？
        ·备份还原
        ·协同修改
        ·控制权限
    2.基本操作
        *checkout        从服务区检出一个仓库到本地来(一般只做一次)
        *commit          将用户去本地代码提交到服务区进行保管
        *updata          将服务区最新的代码更新到用户区本地来
    3.常用指令
        * show log 查看服务区仓库的代码版本(日志)信息
        * revert 撤销，撤销本地未提交的代码（还原成当前版本最初的代码）
        * update to revision 还原，将代码还原到指定的版本  
    4.常见问题：版本冲突
	    产生原因：多个人对同一个文件同一处代码做出了不同修改
	    解决：
		    ·edit conflicts
		    ·手动解决
                删除不想要的内容或者删除3个多余文件 
        避免：
		    禁止多个人修改同一个文件
★★★★★★★★★★★ 2.性能优化 ★★★★★★★★★★★★★★★                
一、图片的种类
    1)jpg                不透明图
    2)png                透明图
    3)gif                动态图
    4)webp               不透明图(用于谷歌、安卓，和jpg的区别是webp更小，但兼容性差)
    5)精灵图/雪碧图       将多个小图片结合在一张图片上，减少服务器的访问次数
    6)iconfont           字体图标(单色，兼容性好)
    7)svg                字体图标(彩色，兼容性差)
    8)base64             将图片编码成字符串形式，优点：不需要请求服务器，适合体积较小的图片 缺点：不合适体积较大的图片，通常用于12kb以下的图片
二、懒加载和预加载
    1.懒加载
        概念：一上来不加载图片，当图片出现在可视区域内才加载
        作用：
            减少无效的资源加载
        在哪里使用：
            电商等图片很多的业务场景
        工作原理：
            图片进入可视区域之后请求图片资源

    2.预加载(一般用的比较少)
        概念：当前页面所有资源加载完毕才加载
        作用：
            资源使用时能从缓存加载，提升用户体验
        在哪里使用：
            页面展示之间有依赖关系需要维护
        工作原理：
            图片等静态资源在使用之前提前请求
三、浏览器渲染引擎
    1.主要模块
        一个渲染引擎主要包括：HTML解析器，CSS解析器，javascript引擎，布局layout模块，绘图模块
        	* HTML解析器：解释HTML文档的解析器，主要作用是将HTML文本解释成DOM树。
            * CSS解析器：级联样式表的解析器，它的作用是为DOM中的各个元素对象计算出样式信息，为布局提供基础设施
            * Javascript引擎：使用Javascript代码可以修改网页的内容，也能修改css的信息，javascript引擎能够解释javascript代码，并通过DOM接口和CSSOM接口来修改网页内容和样式信息，从而改变渲染的结果。
            * 布局（layout）：在DOM创建之后，Webkit需要将其中的元素对象同样式信息结合起来，计算他们的大小位置等布局信息，形成一个能表达这所有信息的内部表示模型
            * 绘图模块（paint）：使用图形库将布局计算后的各个网页的节点绘制成图像结果
    2.渲染过程
        浏览器渲染页面的整个过程：浏览器会从上到下解析文档。如下：
            * 遇见 HTML 标记，调用HTML解析器解析为对应的 token （一个token就是一个标签文本的序列化）并构建 DOM 树（就是一块内存，保存着tokens，建立它们之间的关系）。
            * 遇见 style/link 标记 调用css解析器 处理 CSS 标记并构建 CSSOM 树。
            * 遇见 script 标记 调用 javascript解析器 处理script标记，绑定事件、修改DOM树/CSSOM树 等
            * 将 DOM 与 CSSOM 合并成一个渲染树。
            * 根据渲染树来布局，以计算每个节点的几何信息。
            * 将各个节点绘制到屏幕上。
            注意：需要明白，这五个步骤并不一定按顺序执行完成。如果 DOM 或 CSSOM 被修改，以上过程需要重复执行，
            这样才能计算出哪些像素需要在屏幕上进行重新渲染。实际页面中，CSS 与 JavaScript 往往会多次修改 DOM 和 CSSOM
    3.阻塞渲染
        * css阻塞
			* css 在head中引入会阻塞页面的渲染	
				为什么？
					避免闪屏现象												
			* css 阻塞js的执行，不阻塞js等其他资源的加载					
		* js阻塞
			* 直接引入的js会阻塞页面的渲染
				为什么？
					Javascript代码可能会修改DOM树的结构
			* js顺序执行，阻塞后续js逻辑的执行，不阻塞js等其他资源的加载
				为什么？
					维护依赖关系
    4.预解析
        WebKit 和 Firefox 都进行了这项优化。在执行js脚本时，其他线程会解析文档的其余部分，
        找出并加载需要通过网络加载的其他资源。通过这种方式，资源可以在并行连接上加载，
        从而提高总体速度。请注意，预解析器不会修改 DOM 树，而是将这项工作交由主解析器处理；
        预解析器只会解析外部资源（例如外部脚本、样式表和图片）的引用。

        >在上述的过程中，网页在加载和渲染过程中会发出“DOMContentloaded”和“onload”事件
		>分别在DOM树构建完成之后，以及DOM树构建完并且网页所依赖的资源都加载完之后发生、
		>因为某些资源的加载并不会阻碍DOM树的创建，所以这两个事假多数是不同时发生的
    5.从DOM树到可视化图像
        1) CSS文件被CSS解析器解释成内部表示结构(CSSDOM)
        2) CSS解析器工作完成之后，在DOM树上附加解释后的样式信息，这就是RenderObject树
        3) RenderObject在创建的同时，Webkit会根据网页的结构创建RenderLayer，同时构建一个绘图上下文
        4) 根据绘图上下文生成最终的图像（这一过程需要依赖图形库）

        注意：
            上面介绍的是一个完整的渲染过程，但现代网页很多都是动态的，这意味着在渲染完成之后，由于网页的动画或者用户的交互，
            浏览器其实一直在不停地重复执行渲染过程。（重绘重排），以上的数字表示的是基本顺序，这不是严格一致的，
            这个过程可能重复也可能交叉
四、常见面试题
    1.style和link有什么区别？
        ·style是异步加载，加载html的同时加载样式，会出现闪屏
        ·而link是同步加载，会阻塞渲染(等link标签中的资源加载完毕，才可能渲染)
        ·一般情况下，默认使用link标签，为了解决闪屏问题
    2.什么情况下使用style？
        如果样式不出现首屏/不会一上来就显示。就可以使用style
    3.为什么link标签放在head中？
        更快发送请求，更快渲染页面
    4.为什么script标签放在body的后面？
        因为js可能要操作DOM，放在其他的地方会阻塞html解析
    



*/ 
</script>
  
</body>
</html>